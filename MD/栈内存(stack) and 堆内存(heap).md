## JS中的栈内存和堆内存
   JS中的内存空间分为栈(stack)、堆(heap)、池(池一般归到栈中)；其中栈存放变量，堆存放复杂对象，池存放常量，所以也叫常量池。
  
### 1. 栈数据结构
   栈是一种特殊的列表，栈的元素只能通过列表的一端访问，这一端成为栈顶。栈被成为一种后入先出（LIFO,last-in-first-out)。由于栈具有后入先出的特点，所以任何不在栈顶的元素都无法访问。为了得到栈底的元素，必须先拿掉上面的元素。

### 2. 堆内存数据结构

* 堆是一种经过排序的树形数据结构，每个节点都有值
* 通常我们说的堆的数据结构，是指而二叉堆
* 堆的特点是根节点的值最大或者最小，且根节点的两个子树一个堆
* 堆的这个特性，常用来实现优先队列


### 3. 基本数据类型存储

基本数据类型一般保存在栈内存中，因为基本数据类型占用空间小、大小固定，一般按照值来范访问，属于频繁被访问的数据 
``` string、nubmer、boolean、null、undefined、symbol```


### 4. 引用数据类型

* 引用数据类型一般存放在堆内存中
* 引用数据类型占的空间大、大小不固定
* 如果存放在栈内存中，将影响程序运行的性能
* 引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。
* 当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体


### 5. 举例
``` 
// 基本数据类型-栈内存
let a1 = 0;
// 基本数据类型-栈内存
let a2 = 'this is string';
// 基本数据类型-栈内存
let a3 = null;

// 对象的指针存放在栈内存中，指针指向的对象存放在堆内存中
let b = { m: 20 };
// 数组的指针存放在栈内存中，指针指向的数组存放在堆内存中
let c = [1, 2, 3];会首先检索其在栈中的地址，取得地址后从堆中获得实体
``` 
![blockchain](https://user-gold-cdn.xitu.io/2019/6/25/16b8c0b5752823f6?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)


### 6. 基本数据类型复制
```
let a = 20;
let b = a;
b = 30;
console.log(a); // 20

a、b 都是基本类型，它们的值是存储在栈内存中的，a、b 分别有各自独立的栈空间， 所以修改了 b 的值以后，a 的值并不会发生变化。
```

![blockchain](https://user-gold-cdn.xitu.io/2019/6/25/16b8c0b73d4ebd08?imageView2/0/w/1280/h/960/format/webp/ignore-error/1) 
   
   

### 引用数据类型复制

```
let m = { a: 10, b: 20 };
let n = m;
n.a = 15;
console.log(m.a) // 15

m,n都是引用数据类型，栈内存中存放地址指向堆内存中的对象，引用类型的复制会为变量自动分配一个新的值保存在变量中，但只是引用类型的一个地址指针而已，实际指向的同一个对象，所以修改n.a的值后，相应m.a也就对应改变
```
![blockchain](https://user-gold-cdn.xitu.io/2019/6/25/16b8c0b9df03d885?imageView2/0/w/1280/h/960/format/webp/ignore-error/1) 

### 8. 优缺点
* 在JS中，基本数据类型变量大小固定，并且操作简单容易，所以把它们放入栈中存储。
* 引用类型变量大小不固定，所以把它们分配给堆中，让他们申请空间的时候自己确定大小，这样把它们分开存储能够使得程序运行起来占用的内存最小。
* 栈内存由于它的特点，所以它的系统效率较高。
* 堆内存需要分配空间和地址，还要把地址存到栈中，所以效率低于栈。

### 9. 垃圾回收
栈内存中变量一般在它的当前执行环境结束就会被销毁被垃圾回收制回收， 而堆内存中的变量则不会，因为不确定其他的地方是不是还有一些对它的引用。 堆内存中的变量只有在所有对它的引用都结束的时候才会被回收。


闭包中的变量并不保存中栈内存中，而是保存在堆内存中。 这也就解释了函数调用之后之后为什么闭包还能引用到函数内的变量。
```
function A(){
    let a = 1;
    function B(){
        console.log(a)
    }

    return B
}

let res = A();
res()

```